package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"sort"

	"github.com/renxzen/go-getters/pkg/strings"
	"github.com/renxzen/go-getters/pkg/types"
)

// Generator handles code generation for getter methods.
type Generator struct {
	buf *bytes.Buffer
}

// New creates a new Generator instance.
func New() *Generator {
	return &Generator{
		buf: &bytes.Buffer{},
	}
}

// Line writes a line of code to the buffer.
func (g *Generator) Line(values ...any) {
	for i := range values {
		fmt.Fprint(g.buf, values[i])
	}

	fmt.Fprintln(g.buf)
}

// GenerateGetters generates getter methods for the specified structs.
func (g *Generator) GenerateGetters(structNames []string, parseResult *types.ParseResult) ([]byte, error) {
	packageName := parseResult.PackageName
	structs := parseResult.Structs

	// Write package declaration and header
	g.Line("// Code generated by go-getters. DO NOT EDIT.")
	g.Line()
	g.Line("package ", packageName)
	g.Line()

	// Check if all requested structs exist
	for _, structName := range structNames {
		if _, exists := structs[structName]; !exists {
			return nil, fmt.Errorf("struct %s not found", structName)
		}
	}

	// Collect required imports
	requiredImports := g.collectRequiredImports(structs, structNames, parseResult.Imports)
	if len(requiredImports) > 0 {
		g.Line("import (")
		for _, imp := range requiredImports {
			if imp.IsAliased {
				g.Line(imp.Alias, " \"", imp.Path, "\"")
			} else {
				g.Line("\"", imp.Path, "\"")
			}
		}
		g.Line(")")
		g.Line()
	}

	// Generate getters for each requested struct
	for _, structName := range structNames {
		structInfo := structs[structName]
		g.generateStructGetters(structInfo)
	}

	return format.Source(g.buf.Bytes())
}

// generateStructGetters generates getter methods for a single struct.
func (g *Generator) generateStructGetters(structInfo *types.StructInfo) {
	for _, field := range structInfo.Fields {
		// Skip unexported fields
		if !field.IsExported {
			continue
		}

		g.generateFieldGetter(structInfo.Name, field)
	}
}

// generateFieldGetter generates a getter method for a single field.
func (g *Generator) generateFieldGetter(structName string, field types.FieldInfo) {
	getterPrefix := "Get" // TODO: make the prefix configurable
	getterName := getterPrefix + strings.Capitalize(field.Name)
	zeroValue := field.GetZerovalue()

	// For pointer fields to primitives and specific types, return the dereferenced type
	if field.IsPointer && (field.IsPrimitive() || field.IsSlice) {
		g.Line("func (x *", structName, ") ", getterName, "() ", field.UnderlyingType, " {")
		g.Line("if x != nil && x.", field.Name, " != nil {")
		g.Line("return *x.", field.Name)
		g.Line("}")
		g.Line("return ", zeroValue)
	} else {
		g.Line("func (x *", structName, ") ", getterName, "() ", field.Type, " {")
		g.Line("if x != nil {")
		g.Line("return x.", field.Name)
		g.Line("}")
		g.Line("return ", zeroValue)
	}

	g.Line("}")
	g.Line()
}

// collectRequiredImports collects all import paths needed for the specified structs
func (g *Generator) collectRequiredImports(structs map[string]*types.StructInfo, structNames []string, importsMap map[string]*types.ImportInfo) []*types.ImportInfo {
	importSet := make(map[string]bool)

	for _, structName := range structNames {
		structInfo := structs[structName]
		for _, field := range structInfo.Fields {
			if !field.IsExported {
				continue
			}

			if field.RequiredImport == "" {
				continue
			}

			if importInfo, exists := importsMap[field.RequiredImport]; exists {
				importSet[importInfo.Alias] = true
			}
		}
	}

	// Convert set to sorted slice to ensure deterministic output
	imports := make([]*types.ImportInfo, 0, len(importSet))
	for imp := range importSet {
		info, exists := importsMap[imp]
		if !exists {
			continue
		}

		imports = append(imports, info)
	}
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].Path < imports[j].Path
	})

	return imports
}
